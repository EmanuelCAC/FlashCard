{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport React, { useState, useEffect, useRef, useImperativeHandle } from \"react\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport LogBox from \"react-native-web/dist/exports/LogBox\";\nimport PropTypes from \"prop-types\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nLogBox.ignoreLogs([/equals NaN or INF and will be replaced by/]);\nvar GestureFlipView = React.forwardRef(function (props, ref) {\n  var _panResponder$current;\n  var width = useRef(Math.floor(props.width)).current;\n  var height = useRef(Math.floor(props.height)).current;\n  var _useState = useState(true),\n    _useState2 = _slicedToArray(_useState, 2),\n    cardFace = _useState2[0],\n    setCardFace = _useState2[1];\n  var isAnimating = useRef(false);\n  var isCardFaceSet = useRef(false);\n  var lastScrollX = useRef(0);\n  var flippedValue = useRef(null);\n  var cardFaceRef = useRef(true);\n  var scrollX = useRef(new Animated.Value(0)).current;\n  var enablePan = useRef(props.gestureEnabled);\n  var panResponder = useRef(PanResponder.create({\n    onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(evt) {\n      return true;\n    },\n    onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(evt) {\n      return true;\n    },\n    onMoveShouldSetPanResponder: handleMoveShouldSetPanResponder,\n    onPanResponderGrant: handlePanResponderGrant,\n    onPanResponderMove: handlePanResponderMove,\n    onPanResponderEnd: handlePanResponderEnd\n  }));\n  useEffect(function () {\n    cardFaceRef.current = cardFace;\n  }, [cardFace]);\n  useEffect(function () {\n    enablePan.current = props.gestureEnabled;\n  }, [props.gestureEnabled]);\n  useEffect(function () {\n    scrollX.addListener(function (_ref) {\n      var value = _ref.value;\n      var start = lastScrollX.current;\n      var endRight = start + width;\n      var endLeft = start - width;\n      var rightMidBound = (endRight + start) / 2;\n      var leftMidBound = (endLeft + start) / 2;\n      if (!isCardFaceSet.current) {\n        if (value >= rightMidBound || value <= leftMidBound) {\n          isCardFaceSet.current = true;\n          flippedValue.current = value;\n          setCardFace(function (prev) {\n            return !prev;\n          });\n        }\n      } else {\n        if (value < rightMidBound && value > leftMidBound) {\n          isCardFaceSet.current = false;\n          flippedValue.current = null;\n          setCardFace(function (prev) {\n            return !prev;\n          });\n        }\n      }\n    });\n    return function () {\n      scrollX.removeAllListeners();\n    };\n  }, []);\n\n  function handleMoveShouldSetPanResponder(evt, gestureState) {\n    var dx = Math.abs(gestureState.dx);\n    var dy = Math.abs(gestureState.dy);\n    if (isAnimating.current || !enablePan.current) {\n      return false;\n    }\n    if (cardFace) {\n      return dx > 5;\n    } else {\n      return dx > dy;\n    }\n  }\n\n  function handlePanResponderGrant(evt, gestureState) {\n    isCardFaceSet.current = false;\n    if (cardFaceRef.current) {\n      lastScrollX.current = 0;\n    } else {\n      lastScrollX.current = scrollX._value;\n    }\n  }\n\n  function handlePanResponderMove(evt, gestureState) {\n    if (cardFaceRef.current && flippedValue.current == null) {\n      return Animated.event([{\n        dx: scrollX\n      }], {\n        useNativeDriver: false\n      })(gestureState);\n    } else {\n      var _newState = {};\n      _newState.dx = lastScrollX.current + gestureState.dx;\n      return Animated.event([{\n        dx: scrollX\n      }], {\n        useNativeDriver: false\n      })(_newState);\n    }\n  }\n  function handlePanResponderEnd(evt, gestureState) {\n    var absVx = Math.abs(gestureState.vx);\n    var dx = gestureState.dx;\n    var absDx = Math.abs(dx);\n    var direction = dx >= 0 ? 1 : -1;\n    var goBack = absDx < width / 5 && absVx < 1.0;\n    flipWhileRelease(direction, goBack);\n  }\n  function flipWhileRelease(direction, goBack) {\n    var toValue = cardFaceRef.current ? goBack ? 0 : direction * width : goBack ? lastScrollX.current : direction * width + lastScrollX.current;\n    if (flippedValue.current != null && cardFaceRef.current) {\n      toValue = direction * width + lastScrollX.current;\n    }\n    isAnimating.current = true;\n    Animated.timing(scrollX, {\n      toValue: toValue,\n      duration: 300,\n      useNativeDriver: false\n    }).start(function () {\n      isAnimating.current = false;\n      flippedValue.current = null;\n      props.onFlipEnd && props.onFlipEnd();\n    });\n  }\n  function Flip(direction) {\n    if (isAnimating.current) {\n      return;\n    }\n    isCardFaceSet.current = false;\n    if (cardFaceRef.current) {\n      lastScrollX.current = 0;\n      scrollX.setValue(0);\n    } else {\n      lastScrollX.current = scrollX._value;\n    }\n    var toValue = cardFaceRef.current ? direction * width : direction * width + lastScrollX.current;\n    if (flippedValue.current != null && cardFaceRef.current) {\n      toValue = direction * width + lastScrollX.current;\n    }\n    isAnimating.current = true;\n    Animated.timing(scrollX, {\n      toValue: toValue,\n      duration: 300,\n      useNativeDriver: false\n    }).start(function () {\n      isAnimating.current = false;\n      flippedValue.current = null;\n      props.onFlipEnd && props.onFlipEnd();\n    });\n  }\n  useImperativeHandle(ref, function () {\n    return {\n      flipLeft: function flipLeft() {\n        return Flip(-1);\n      },\n      flipRight: function flipRight() {\n        return Flip(1);\n      }\n    };\n  });\n  var renderFront = function renderFront() {\n    return _jsx(Animated.View, {\n      style: [styles.cardContainer, {\n        opacity: cardFace ? 1 : 0,\n        zIndex: cardFace ? 5 : 1,\n        height: height,\n        width: width,\n        transform: [{\n          perspective: props.perspective\n        }, {\n          rotateY: scrollX.interpolate({\n            inputRange: [-width, 0, width],\n            outputRange: Platform.select({\n              ios: [\"180deg\", \"0deg\", \"-180deg\"],\n              android: [\"-180deg\", \"0deg\", \"180deg\"]\n            })\n          })\n        }]\n      }],\n      children: _jsx(View, {\n        pointerEvents: cardFace ? \"auto\" : \"none\",\n        children: props.children[0]\n      })\n    });\n  };\n  var renderBack = function renderBack() {\n    return _jsx(Animated.View, {\n      style: [styles.cardContainer, {\n        opacity: cardFace ? 0 : 1,\n        zIndex: cardFace ? 1 : 5,\n        height: height,\n        width: width,\n        transform: [{\n          perspective: props.perspective\n        }, {\n          rotateY: scrollX.interpolate({\n            inputRange: [-width, 0, width],\n            outputRange: Platform.select({\n              ios: [\"0deg\", \"-180deg\", \"-360deg\"],\n              android: [\"0deg\", \"180deg\", \"360deg\"]\n            })\n          })\n        }]\n      }],\n      children: _jsx(View, {\n        pointerEvents: cardFace ? \"none\" : \"auto\",\n        children: props.children[1]\n      })\n    });\n  };\n  return _jsxs(View, _objectSpread(_objectSpread({}, (_panResponder$current = panResponder.current) == null ? void 0 : _panResponder$current.panHandlers), {}, {\n    style: {\n      backgroundColor: \"transparent\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      height: height,\n      width: width\n    },\n    children: [renderBack(), renderFront()]\n  }));\n});\nGestureFlipView.propTypes = {\n  onFlipEnd: PropTypes.func,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  perspective: PropTypes.number,\n  gestureEnabled: PropTypes.bool\n};\nGestureFlipView.defaultProps = {\n  perspective: -1000,\n  gestureEnabled: true\n};\nvar styles = StyleSheet.create({\n  cardContainer: {\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    position: \"absolute\",\n    flex: 1,\n    backgroundColor: \"transparent\"\n  }\n});\nexport default GestureFlipView;","map":{"version":3,"names":["React","useState","useEffect","useRef","useImperativeHandle","PropTypes","LogBox","ignoreLogs","GestureFlipView","forwardRef","props","ref","width","Math","floor","current","height","cardFace","setCardFace","isAnimating","isCardFaceSet","lastScrollX","flippedValue","cardFaceRef","scrollX","Animated","Value","enablePan","gestureEnabled","panResponder","PanResponder","create","onStartShouldSetResponderCapture","evt","onMoveShouldSetResponderCapture","onMoveShouldSetPanResponder","handleMoveShouldSetPanResponder","onPanResponderGrant","handlePanResponderGrant","onPanResponderMove","handlePanResponderMove","onPanResponderEnd","handlePanResponderEnd","addListener","value","start","endRight","endLeft","rightMidBound","leftMidBound","prev","removeAllListeners","gestureState","dx","abs","dy","_value","event","useNativeDriver","_newState","absVx","vx","absDx","direction","goBack","flipWhileRelease","toValue","timing","duration","onFlipEnd","Flip","setValue","flipLeft","flipRight","renderFront","styles","cardContainer","opacity","zIndex","transform","perspective","rotateY","interpolate","inputRange","outputRange","Platform","select","ios","android","children","renderBack","panHandlers","backgroundColor","justifyContent","alignItems","propTypes","func","number","isRequired","bool","defaultProps","StyleSheet","position","flex"],"sources":["C:/Users/cg3008398/Desktop/React-projeto/FlashCard/node_modules/react-native-gesture-flip-card/gestureFlipView.js"],"sourcesContent":["import React, { useState, useEffect, useRef, useImperativeHandle } from \"react\";\nimport {\n  View,\n  Animated,\n  PanResponder,\n  Platform,\n  StyleSheet,\n  LogBox,\n} from \"react-native\";\nimport PropTypes from \"prop-types\";\nLogBox.ignoreLogs([/equals NaN or INF and will be replaced by/]);\n\nconst GestureFlipView = React.forwardRef((props, ref) => {\n  const width = useRef(Math.floor(props.width)).current;\n  const height = useRef(Math.floor(props.height)).current;\n  const [cardFace, setCardFace] = useState(true);\n\n  const isAnimating = useRef(false);\n  const isCardFaceSet = useRef(false);\n  const lastScrollX = useRef(0);\n  const flippedValue = useRef(null);\n  const cardFaceRef = useRef(true);\n  const scrollX = useRef(new Animated.Value(0)).current;\n  const enablePan = useRef(props.gestureEnabled);\n  const panResponder = useRef(\n    PanResponder.create({\n      onStartShouldSetResponderCapture: (evt) => true,\n      onMoveShouldSetResponderCapture: (evt) => true,\n      onMoveShouldSetPanResponder: handleMoveShouldSetPanResponder,\n      onPanResponderGrant: handlePanResponderGrant,\n      onPanResponderMove: handlePanResponderMove,\n      onPanResponderEnd: handlePanResponderEnd,\n    })\n  );\n\n  useEffect(() => {\n    cardFaceRef.current = cardFace;\n  }, [cardFace]);\n\n  useEffect(() => {\n    enablePan.current = props.gestureEnabled;\n  }, [props.gestureEnabled]);\n\n  useEffect(() => {\n    scrollX.addListener(({ value }) => {\n      const start = lastScrollX.current;\n      const endRight = start + width;\n      const endLeft = start - width;\n      const rightMidBound = (endRight + start) / 2;\n      const leftMidBound = (endLeft + start) / 2;\n\n      if (!isCardFaceSet.current) {\n        if (value >= rightMidBound || value <= leftMidBound) {\n          isCardFaceSet.current = true;\n          flippedValue.current = value;\n          setCardFace((prev) => !prev);\n        }\n      } else {\n        if (value < rightMidBound && value > leftMidBound) {\n          isCardFaceSet.current = false;\n          flippedValue.current = null;\n          setCardFace((prev) => !prev);\n        }\n      }\n    });\n\n    return () => {\n      scrollX.removeAllListeners();\n    };\n  }, []);\n\n  // if pan can response, decide move event can effect.\n  function handleMoveShouldSetPanResponder(evt, gestureState) {\n    const dx = Math.abs(gestureState.dx);\n    const dy = Math.abs(gestureState.dy);\n    if (isAnimating.current || !enablePan.current) {\n      return false;\n    }\n    if (cardFace) {\n      return dx > 5;\n    } else {\n      return dx > dy;\n    }\n  }\n\n  // call once, when move start effect.\n  function handlePanResponderGrant(evt, gestureState) {\n    isCardFaceSet.current = false;\n    if (cardFaceRef.current) {\n      lastScrollX.current = 0;\n    } else {\n      lastScrollX.current = scrollX._value;\n    }\n  }\n\n  // when moving on responder.\n  function handlePanResponderMove(evt, gestureState) {\n    if (cardFaceRef.current && flippedValue.current == null) {\n      // PanResponder run on JS thread, so we can't use native driver here.\n      return Animated.event([{ dx: scrollX }], {\n        useNativeDriver: false,\n      })(gestureState);\n    } else {\n      let _newState = {};\n      _newState.dx = lastScrollX.current + gestureState.dx;\n      return Animated.event([{ dx: scrollX }], {\n        useNativeDriver: false,\n      })(_newState);\n    }\n  }\n\n  function handlePanResponderEnd(evt, gestureState) {\n    const absVx = Math.abs(gestureState.vx);\n    const dx = gestureState.dx;\n    const absDx = Math.abs(dx);\n    const direction = dx >= 0 ? 1 : -1;\n    const goBack = absDx < width / 5 && absVx < 1.0;\n    flipWhileRelease(direction, goBack);\n  }\n\n  function flipWhileRelease(direction, goBack) {\n    let toValue = cardFaceRef.current\n      ? goBack\n        ? 0\n        : direction * width\n      : goBack\n      ? lastScrollX.current\n      : direction * width + lastScrollX.current;\n    if (flippedValue.current != null && cardFaceRef.current) {\n      toValue = direction * width + lastScrollX.current;\n    }\n    isAnimating.current = true;\n    Animated.timing(scrollX, {\n      toValue: toValue,\n      duration: 300,\n      useNativeDriver: false,\n    }).start(() => {\n      isAnimating.current = false;\n      flippedValue.current = null;\n      props.onFlipEnd && props.onFlipEnd();\n    });\n  }\n\n  function Flip(direction) {\n    if (isAnimating.current) {\n      return;\n    }\n    isCardFaceSet.current = false;\n    if (cardFaceRef.current) {\n      lastScrollX.current = 0;\n      scrollX.setValue(0);\n    } else {\n      lastScrollX.current = scrollX._value;\n    }\n    let toValue = cardFaceRef.current\n      ? direction * width\n      : direction * width + lastScrollX.current;\n    if (flippedValue.current != null && cardFaceRef.current) {\n      toValue = direction * width + lastScrollX.current;\n    }\n    isAnimating.current = true;\n    Animated.timing(scrollX, {\n      toValue: toValue,\n      duration: 300,\n      useNativeDriver: false,\n    }).start(() => {\n      isAnimating.current = false;\n      flippedValue.current = null;\n      props.onFlipEnd && props.onFlipEnd();\n    });\n  }\n\n  useImperativeHandle(ref, () => ({\n    flipLeft: () => Flip(-1),\n    flipRight: () => Flip(1),\n  }));\n\n  const renderFront = () => {\n    return (\n      <Animated.View\n        style={[\n          styles.cardContainer,\n          {\n            opacity: cardFace ? 1 : 0,\n            zIndex: cardFace ? 5 : 1,\n            height: height,\n            width: width,\n            transform: [\n              { perspective: props.perspective },\n              {\n                rotateY: scrollX.interpolate({\n                  inputRange: [-width, 0, width],\n                  outputRange: Platform.select({\n                    ios: [\"180deg\", \"0deg\", \"-180deg\"],\n                    android: [\"-180deg\", \"0deg\", \"180deg\"],\n                  }),\n                }),\n              },\n            ],\n          },\n        ]}\n      >\n        <View pointerEvents={cardFace ? \"auto\" : \"none\"}>\n          {props.children[0]}\n        </View>\n      </Animated.View>\n    );\n  };\n\n  const renderBack = () => {\n    return (\n      <Animated.View\n        style={[\n          styles.cardContainer,\n          {\n            opacity: cardFace ? 0 : 1,\n            zIndex: cardFace ? 1 : 5,\n            height: height,\n            width: width,\n            transform: [\n              { perspective: props.perspective },\n              {\n                rotateY: scrollX.interpolate({\n                  inputRange: [-width, 0, width],\n                  outputRange: Platform.select({\n                    ios: [\"0deg\", \"-180deg\", \"-360deg\"],\n                    android: [\"0deg\", \"180deg\", \"360deg\"],\n                  }),\n                }),\n              },\n            ],\n          },\n        ]}\n      >\n        <View pointerEvents={cardFace ? \"none\" : \"auto\"}>\n          {props.children[1]}\n        </View>\n      </Animated.View>\n    );\n  };\n\n  return (\n    <View\n      {...panResponder.current?.panHandlers}\n      style={{\n        backgroundColor: \"transparent\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        height: height,\n        width: width,\n      }}\n    >\n      {renderBack()}\n      {renderFront()}\n    </View>\n  );\n});\n\nGestureFlipView.propTypes = {\n  onFlipEnd: PropTypes.func,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  perspective: PropTypes.number,\n  gestureEnabled: PropTypes.bool,\n};\n\nGestureFlipView.defaultProps = {\n  perspective: -1000,\n  gestureEnabled: true,\n};\n\nconst styles = StyleSheet.create({\n  cardContainer: {\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    position: \"absolute\",\n    flex: 1,\n    backgroundColor: \"transparent\",\n  },\n});\n\nexport default GestureFlipView;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}